// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const authenticate = `-- name: Authenticate :one
SELECT COUNT(SUBQUERY.DataInserimento)
FROM (
   SELECT MIN(SP.DataInserimento) AS DataInserimento
   FROM STORICO_PASSWORD SP 
   WHERE SP.Username = $1 AND SP.Password = $2
) AS SUBQUERY
`

type AuthenticateParams struct {
	Username string
	Password string
}

func (q *Queries) Authenticate(ctx context.Context, arg AuthenticateParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, authenticate, arg.Username, arg.Password)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const checkIfMemberStillInChat = `-- name: CheckIfMemberStillInChat :one
SELECT M.DataEntrata
FROM MEMBRO M FULL OUTER JOIN USCITA U ON (M.IDMEMBRO = U.IDMEMBRO)
WHERE M.IDMEMBRO = $1
	AND U.IDMEMBRO IS NULL
`

func (q *Queries) CheckIfMemberStillInChat(ctx context.Context, idmembro int32) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, checkIfMemberStillInChat, idmembro)
	var dataentrata sql.NullTime
	err := row.Scan(&dataentrata)
	return dataentrata, err
}

const checkIfUserStillInChat = `-- name: CheckIfUserStillInChat :one
SELECT COUNT(*)
FROM MEMBRO M FULL OUTER JOIN USCITA U ON (M.IDMEMBRO = U.IDMEMBRO)
WHERE M.USERNAME = $1
	AND M.IDCHAT = $2
	AND U.IDMEMBRO IS NULL
`

type CheckIfUserStillInChatParams struct {
	Username string
	Idchat   int32
}

func (q *Queries) CheckIfUserStillInChat(ctx context.Context, arg CheckIfUserStillInChatParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkIfUserStillInChat, arg.Username, arg.Idchat)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllPossibleFollowings = `-- name: GetAllPossibleFollowings :many
SELECT u1.username AS U1, u2.username AS U2
FROM UTENTE u1 FULL OUTER JOIN UTENTE u2 ON (True)
ORDER BY random()
`

type GetAllPossibleFollowingsRow struct {
	U1 sql.NullString
	U2 sql.NullString
}

func (q *Queries) GetAllPossibleFollowings(ctx context.Context) ([]GetAllPossibleFollowingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPossibleFollowings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPossibleFollowingsRow
	for rows.Next() {
		var i GetAllPossibleFollowingsRow
		if err := rows.Scan(&i.U1, &i.U2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPossibleMembers = `-- name: GetAllPossibleMembers :many
SELECT u.username AS username, c.IdChat AS idchat
FROM UTENTE u FULL OUTER JOIN CHAT c ON (True)
ORDER BY random()
`

type GetAllPossibleMembersRow struct {
	Username sql.NullString
	Idchat   sql.NullInt32
}

func (q *Queries) GetAllPossibleMembers(ctx context.Context) ([]GetAllPossibleMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPossibleMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPossibleMembersRow
	for rows.Next() {
		var i GetAllPossibleMembersRow
		if err := rows.Scan(&i.Username, &i.Idchat); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatIds = `-- name: GetChatIds :many
SELECT IdMembro, IdChat FROM MEMBRO WHERE Username = $1
`

type GetChatIdsRow struct {
	Idmembro int32
	Idchat   int32
}

func (q *Queries) GetChatIds(ctx context.Context, username string) ([]GetChatIdsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatIds, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatIdsRow
	for rows.Next() {
		var i GetChatIdsRow
		if err := rows.Scan(&i.Idmembro, &i.Idchat); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatInfos = `-- name: GetChatInfos :one
SELECT Nome, Descrizione FROM CHAT WHERE idChat = $1
`

type GetChatInfosRow struct {
	Nome        string
	Descrizione string
}

func (q *Queries) GetChatInfos(ctx context.Context, idchat int32) (GetChatInfosRow, error) {
	row := q.db.QueryRowContext(ctx, getChatInfos, idchat)
	var i GetChatInfosRow
	err := row.Scan(&i.Nome, &i.Descrizione)
	return i, err
}

const getChatMembers = `-- name: GetChatMembers :many
SELECT IdMembro FROM MEMBRO WHERE MEMBRO.idchat = $1
`

func (q *Queries) GetChatMembers(ctx context.Context, idchat int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getChatMembers, idchat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var idmembro int32
		if err := rows.Scan(&idmembro); err != nil {
			return nil, err
		}
		items = append(items, idmembro)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMessages = `-- name: GetChatMessages :many
SELECT testo, TimestampInvio, username FROM MESSAGGIO JOIN MEMBRO ON MEMBRO.IdMembro = MESSAGGIO.Mittente WHERE MEMBRO.idChat = $1
`

type GetChatMessagesRow struct {
	Testo          string
	Timestampinvio time.Time
	Username       string
}

func (q *Queries) GetChatMessages(ctx context.Context, idchat int32) ([]GetChatMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatMessages, idchat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatMessagesRow
	for rows.Next() {
		var i GetChatMessagesRow
		if err := rows.Scan(&i.Testo, &i.Timestampinvio, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentMember = `-- name: GetCurrentMember :one
SELECT IdMembro, DataEntrata
FROM MEMBRO
WHERE Username = $1 AND IdChat = $2
ORDER BY DataEntrata ASC
LIMIT 1
`

type GetCurrentMemberParams struct {
	Username string
	Idchat   int32
}

type GetCurrentMemberRow struct {
	Idmembro    int32
	Dataentrata time.Time
}

func (q *Queries) GetCurrentMember(ctx context.Context, arg GetCurrentMemberParams) (GetCurrentMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentMember, arg.Username, arg.Idchat)
	var i GetCurrentMemberRow
	err := row.Scan(&i.Idmembro, &i.Dataentrata)
	return i, err
}

const getDataOfMember = `-- name: GetDataOfMember :one
SELECT username, idchat, DataEntrata
FROM MEMBRO
WHERE IdMembro = $1
`

type GetDataOfMemberRow struct {
	Username    string
	Idchat      int32
	Dataentrata time.Time
}

func (q *Queries) GetDataOfMember(ctx context.Context, idmembro int32) (GetDataOfMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getDataOfMember, idmembro)
	var i GetDataOfMemberRow
	err := row.Scan(&i.Username, &i.Idchat, &i.Dataentrata)
	return i, err
}

const getFollowers = `-- name: GetFollowers :many
SELECT usernameseguace FROM SEGUIRE WHERE usernameseguito = $1 AND DataFine IS NULL
`

func (q *Queries) GetFollowers(ctx context.Context, usernameseguito string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFollowers, usernameseguito)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var usernameseguace string
		if err := rows.Scan(&usernameseguace); err != nil {
			return nil, err
		}
		items = append(items, usernameseguace)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowing = `-- name: GetFollowing :many
SELECT usernameseguito FROM SEGUIRE WHERE usernameseguace = $1 AND DataFine IS NULL
`

func (q *Queries) GetFollowing(ctx context.Context, usernameseguace string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFollowing, usernameseguace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var usernameseguito string
		if err := rows.Scan(&usernameseguito); err != nil {
			return nil, err
		}
		items = append(items, usernameseguito)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullFeed = `-- name: GetFullFeed :many
SELECT titolo, autore, TimestampPubblicazione, Testo FROM SEGUIRE 
JOIN CONTENUTO ON CONTENUTO.Autore = SEGUIRE.usernameSeguito  
WHERE SEGUIRE.usernameseguace = ($1) AND datafine IS NULL AND IdContenutoPadre IS NULL
`

type GetFullFeedRow struct {
	Titolo                 sql.NullString
	Autore                 string
	Timestamppubblicazione time.Time
	Testo                  string
}

func (q *Queries) GetFullFeed(ctx context.Context, usernameseguace string) ([]GetFullFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, getFullFeed, usernameseguace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFullFeedRow
	for rows.Next() {
		var i GetFullFeedRow
		if err := rows.Scan(
			&i.Titolo,
			&i.Autore,
			&i.Timestamppubblicazione,
			&i.Testo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationRec = `-- name: GetLocationRec :many
WITH recursive getSuperregions(idregione, superregione)
AS(
	(
		select idregione, superregione
		from regione
	) union all (
		select g.idregione, a.superregione
		from regione g, getSuperregions a
		where g.superregione = a.idregione
	)
)

select nome
from getSuperregions g join regione r on (g.superregione = r.idregione)
where g.idregione = $1
`

func (q *Queries) GetLocationRec(ctx context.Context, idregione int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getLocationRec, idregione)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var nome string
		if err := rows.Scan(&nome); err != nil {
			return nil, err
		}
		items = append(items, nome)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocations = `-- name: GetLocations :many
SELECT idregione, nome, superregione FROM Regione
`

func (q *Queries) GetLocations(ctx context.Context) ([]Regione, error) {
	rows, err := q.db.QueryContext(ctx, getLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Regione
	for rows.Next() {
		var i Regione
		if err := rows.Scan(&i.Idregione, &i.Nome, &i.Superregione); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberId = `-- name: GetMemberId :one
SELECT IdMembro
FROM MEMBRO
WHERE DataEntrata = $1 AND Username = $2 AND IdChat = $3
`

type GetMemberIdParams struct {
	Dataentrata time.Time
	Username    string
	Idchat      int32
}

func (q *Queries) GetMemberId(ctx context.Context, arg GetMemberIdParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getMemberId, arg.Dataentrata, arg.Username, arg.Idchat)
	var idmembro int32
	err := row.Scan(&idmembro)
	return idmembro, err
}

const getPastPasswords = `-- name: GetPastPasswords :many
SELECT Password FROM  STORICO_PASSWORD WHERE username = $1
`

func (q *Queries) GetPastPasswords(ctx context.Context, username string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getPastPasswords, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var password string
		if err := rows.Scan(&password); err != nil {
			return nil, err
		}
		items = append(items, password)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomAdmin = `-- name: GetRandomAdmin :one
SELECT IdMembro
FROM AMMINISTRATORE
ORDER BY random()
LIMIT 1
`

func (q *Queries) GetRandomAdmin(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getRandomAdmin)
	var idmembro int32
	err := row.Scan(&idmembro)
	return idmembro, err
}

const getRandomAdminInChat = `-- name: GetRandomAdminInChat :one
SELECT a.IdMembro
  FROM AMMINISTRATORE a JOIN MEMBRO m ON (a.IdMembro = m.IdMembro)
  WHERE m.IdChat = $1
  ORDER BY random()
  LIMIT 1
`

func (q *Queries) GetRandomAdminInChat(ctx context.Context, idchat int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getRandomAdminInChat, idchat)
	var idmembro int32
	err := row.Scan(&idmembro)
	return idmembro, err
}

const getRandomChat = `-- name: GetRandomChat :one
SELECT IdChat
  FROM CHAT
  ORDER BY random()
  LIMIT 1
`

func (q *Queries) GetRandomChat(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getRandomChat)
	var idchat int32
	err := row.Scan(&idchat)
	return idchat, err
}

const getRandomMember = `-- name: GetRandomMember :one
SELECT IdMembro
FROM MEMBRO
ORDER BY random()
LIMIT 1
`

func (q *Queries) GetRandomMember(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getRandomMember)
	var idmembro int32
	err := row.Scan(&idmembro)
	return idmembro, err
}

const getRandomMemberFromAnyChat = `-- name: GetRandomMemberFromAnyChat :many
SELECT m.IdMembro, m.IdChat
FROM MEMBRO m 
ORDER BY random()
`

type GetRandomMemberFromAnyChatRow struct {
	Idmembro int32
	Idchat   int32
}

func (q *Queries) GetRandomMemberFromAnyChat(ctx context.Context) ([]GetRandomMemberFromAnyChatRow, error) {
	rows, err := q.db.QueryContext(ctx, getRandomMemberFromAnyChat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRandomMemberFromAnyChatRow
	for rows.Next() {
		var i GetRandomMemberFromAnyChatRow
		if err := rows.Scan(&i.Idmembro, &i.Idchat); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomMemberInChat = `-- name: GetRandomMemberInChat :one
SELECT m.IdMembro, m.DataEntrata
FROM MEMBRO m full outer join USCITA u ON (m.IdMembro = u.IdMembro)
WHERE u.IdMembro IS NULL AND m.IdChat = $1
`

type GetRandomMemberInChatRow struct {
	Idmembro    sql.NullInt32
	Dataentrata sql.NullTime
}

func (q *Queries) GetRandomMemberInChat(ctx context.Context, idchat int32) (GetRandomMemberInChatRow, error) {
	row := q.db.QueryRowContext(ctx, getRandomMemberInChat, idchat)
	var i GetRandomMemberInChatRow
	err := row.Scan(&i.Idmembro, &i.Dataentrata)
	return i, err
}

const getRandomUser = `-- name: GetRandomUser :one

SELECT Username
FROM UTENTE
ORDER BY random()
LIMIT 1
`

// random accesses
func (q *Queries) GetRandomUser(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getRandomUser)
	var username string
	err := row.Scan(&username)
	return username, err
}

const getSpecificPost = `-- name: GetSpecificPost :many
SELECT autore, testo, idcontenuto, timestamppubblicazione, titolo, idregione, usernamepadre, idcontenutopadre, likedelta FROM CONTENUTO WHERE Autore = $1 AND IdContenuto = $2
`

type GetSpecificPostParams struct {
	Autore      string
	Idcontenuto int32
}

func (q *Queries) GetSpecificPost(ctx context.Context, arg GetSpecificPostParams) ([]Contenuto, error) {
	rows, err := q.db.QueryContext(ctx, getSpecificPost, arg.Autore, arg.Idcontenuto)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contenuto
	for rows.Next() {
		var i Contenuto
		if err := rows.Scan(
			&i.Autore,
			&i.Testo,
			&i.Idcontenuto,
			&i.Timestamppubblicazione,
			&i.Titolo,
			&i.Idregione,
			&i.Usernamepadre,
			&i.Idcontenutopadre,
			&i.Likedelta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAdmin = `-- name: InsertAdmin :exec
INSERT INTO AMMINISTRATORE (
  IdMembro
) VALUES ( $1 )
`

func (q *Queries) InsertAdmin(ctx context.Context, idmembro int32) error {
	_, err := q.db.ExecContext(ctx, insertAdmin, idmembro)
	return err
}

const insertChat = `-- name: InsertChat :one
INSERT INTO CHAT (Nome, Descrizione)
  VALUES ($1, $2)
  RETURNING IdChat
`

type InsertChatParams struct {
	Nome        string
	Descrizione string
}

func (q *Queries) InsertChat(ctx context.Context, arg InsertChatParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertChat, arg.Nome, arg.Descrizione)
	var idchat int32
	err := row.Scan(&idchat)
	return idchat, err
}

const insertExit = `-- name: InsertExit :exec
INSERT INTO USCITA (
IdMembro, DataUscita, Motivazione, IdMembroResponsabile
) VALUES ($1, $2, $3, $4)
`

type InsertExitParams struct {
	Idmembro             int32
	Datauscita           time.Time
	Motivazione          sql.NullString
	Idmembroresponsabile sql.NullInt32
}

func (q *Queries) InsertExit(ctx context.Context, arg InsertExitParams) error {
	_, err := q.db.ExecContext(ctx, insertExit,
		arg.Idmembro,
		arg.Datauscita,
		arg.Motivazione,
		arg.Idmembroresponsabile,
	)
	return err
}

const insertFollower = `-- name: InsertFollower :exec
INSERT INTO SEGUIRE (UsernameSeguace, UsernameSeguito, DataInizio, DataFine)
  VALUES ($1, $2, $3, $4)
`

type InsertFollowerParams struct {
	Usernameseguace string
	Usernameseguito string
	Datainizio      time.Time
	Datafine        sql.NullTime
}

func (q *Queries) InsertFollower(ctx context.Context, arg InsertFollowerParams) error {
	_, err := q.db.ExecContext(ctx, insertFollower,
		arg.Usernameseguace,
		arg.Usernameseguito,
		arg.Datainizio,
		arg.Datafine,
	)
	return err
}

const insertMember = `-- name: InsertMember :one
INSERT INTO MEMBRO (
  DataEntrata, Username, IdChat, Amministratore
) VALUES ( $1, $2, $3, $4 )
RETURNING IdMembro
`

type InsertMemberParams struct {
	Dataentrata    time.Time
	Username       string
	Idchat         int32
	Amministratore sql.NullInt32
}

func (q *Queries) InsertMember(ctx context.Context, arg InsertMemberParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertMember,
		arg.Dataentrata,
		arg.Username,
		arg.Idchat,
		arg.Amministratore,
	)
	var idmembro int32
	err := row.Scan(&idmembro)
	return idmembro, err
}

const insertMessage = `-- name: InsertMessage :exec
INSERT INTO MESSAGGIO (Testo, TimestampInvio, Mittente) VALUES ($1, $2, $3)
`

type InsertMessageParams struct {
	Testo          string
	Timestampinvio time.Time
	Mittente       int32
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) error {
	_, err := q.db.ExecContext(ctx, insertMessage, arg.Testo, arg.Timestampinvio, arg.Mittente)
	return err
}

const insertPassword = `-- name: InsertPassword :exec
INSERT INTO STORICO_PASSWORD (Username, Password, DataInserimento)
    VALUES ($1, $2, $3)
`

type InsertPasswordParams struct {
	Username        string
	Password        string
	Datainserimento time.Time
}

func (q *Queries) InsertPassword(ctx context.Context, arg InsertPasswordParams) error {
	_, err := q.db.ExecContext(ctx, insertPassword, arg.Username, arg.Password, arg.Datainserimento)
	return err
}

const insertRegion = `-- name: InsertRegion :exec
INSERT INTO REGIONE (Nome, Superregione) 
  VALUES ($1, $2)
`

type InsertRegionParams struct {
	Nome         string
	Superregione sql.NullInt32
}

func (q *Queries) InsertRegion(ctx context.Context, arg InsertRegionParams) error {
	_, err := q.db.ExecContext(ctx, insertRegion, arg.Nome, arg.Superregione)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO UTENTE (Username, DataDiNascita, Nome, Cognome, Domicilio, NumeroSeguaci) 
    VALUES             ($1,    $2,        $3,   $4,      $5, 0)
`

type InsertUserParams struct {
	Username      string
	Datadinascita sql.NullTime
	Nome          sql.NullString
	Cognome       sql.NullString
	Domicilio     sql.NullInt32
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.ExecContext(ctx, insertUser,
		arg.Username,
		arg.Datadinascita,
		arg.Nome,
		arg.Cognome,
		arg.Domicilio,
	)
	return err
}

const isValidAdmin = `-- name: IsValidAdmin :one
SELECT COUNT(m.IdMembro)
FROM AMMINISTRATORE a JOIN MEMBRO m ON (a.IdMembro = m.IdMembro)
WHERE a.IdMembro = $1 AND m.IdChat = $2
`

type IsValidAdminParams struct {
	Idmembro int32
	Idchat   int32
}

func (q *Queries) IsValidAdmin(ctx context.Context, arg IsValidAdminParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isValidAdmin, arg.Idmembro, arg.Idchat)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const testQuery = `-- name: TestQuery :one
SELECT nome, descrizione, idchat FROM CHAT
`

func (q *Queries) TestQuery(ctx context.Context) (Chat, error) {
	row := q.db.QueryRowContext(ctx, testQuery)
	var i Chat
	err := row.Scan(&i.Nome, &i.Descrizione, &i.Idchat)
	return i, err
}

const updateNumberOfFollowers = `-- name: UpdateNumberOfFollowers :exec
UPDATE UTENTE
SET NumeroSeguaci = NumeroSeguaci + $2 
WHERE Username = $1
`

type UpdateNumberOfFollowersParams struct {
	Username      string
	Numeroseguaci int32
}

func (q *Queries) UpdateNumberOfFollowers(ctx context.Context, arg UpdateNumberOfFollowersParams) error {
	_, err := q.db.ExecContext(ctx, updateNumberOfFollowers, arg.Username, arg.Numeroseguaci)
	return err
}
